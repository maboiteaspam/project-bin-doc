<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>/home/maboiteaspam/Bureau/project-bin-doc/node_modules/commander/index.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Cluc.html">Cluc</a></li>
                                <li><a href="../classes/ClucAnswer.html">ClucAnswer</a></li>
                                <li><a href="../classes/ClucChildProcess.html">ClucChildProcess</a></li>
                                <li><a href="../classes/ClucConfirm.html">ClucConfirm</a></li>
                                <li><a href="../classes/ClucContext.html">ClucContext</a></li>
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/ClucDieOnError.html">ClucDieOnError</a></li>
                                <li><a href="../classes/ClucDisplay.html">ClucDisplay</a></li>
                                <li><a href="../classes/ClucMustNot.html">ClucMustNot</a></li>
                                <li><a href="../classes/ClucProgress.html">ClucProgress</a></li>
                                <li><a href="../classes/ClucRule.html">ClucRule</a></li>
                                <li><a href="../classes/ClucSpin.html">ClucSpin</a></li>
                                <li><a href="../classes/ClucSpinUntil.html">ClucSpinUntil</a></li>
                                <li><a href="../classes/ClucSsh.html">ClucSsh</a></li>
                                <li><a href="../classes/ClucSSHContext.html">ClucSSHContext</a></li>
                                <li><a href="../classes/ClucSuccess.html">ClucSuccess</a></li>
                                <li><a href="../classes/ClucWarn.html">ClucWarn</a></li>
                                <li><a href="../classes/ClucWatch.html">ClucWatch</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: /home/maboiteaspam/Bureau/project-bin-doc/node_modules/commander/index.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">

/**
 * Module dependencies.
 */

var EventEmitter = require(&#x27;events&#x27;).EventEmitter;
var spawn = require(&#x27;child_process&#x27;).spawn;
var readlink = require(&#x27;graceful-readlink&#x27;).readlinkSync;
var path = require(&#x27;path&#x27;);
var dirname = path.dirname;
var basename = path.basename;
var fs = require(&#x27;fs&#x27;);

/**
 * Expose the root command.
 */

exports = module.exports = new Command();

/**
 * Expose &#x60;Command&#x60;.
 */

exports.Command = Command;

/**
 * Expose &#x60;Option&#x60;.
 */

exports.Option = Option;

/**
 * Initialize a new &#x60;Option&#x60; with the given &#x60;flags&#x60; and &#x60;description&#x60;.
 *
 * @param {String} flags
 * @param {String} description
 * @api public
 */

function Option(flags, description) {
  this.flags = flags;
  this.required = ~flags.indexOf(&#x27;&lt;&#x27;);
  this.optional = ~flags.indexOf(&#x27;[&#x27;);
  this.bool = !~flags.indexOf(&#x27;-no-&#x27;);
  flags = flags.split(/[ ,|]+/);
  if (flags.length &gt; 1 &amp;&amp; !/^[[&lt;]/.test(flags[1])) this.short = flags.shift();
  this.long = flags.shift();
  this.description = description || &#x27;&#x27;;
}

/**
 * Return option name.
 *
 * @return {String}
 * @api private
 */

Option.prototype.name = function() {
  return this.long
    .replace(&#x27;--&#x27;, &#x27;&#x27;)
    .replace(&#x27;no-&#x27;, &#x27;&#x27;);
};

/**
 * Check if &#x60;arg&#x60; matches the short or long flag.
 *
 * @param {String} arg
 * @return {Boolean}
 * @api private
 */

Option.prototype.is = function(arg) {
  return arg == this.short || arg == this.long;
};

/**
 * Initialize a new &#x60;Command&#x60;.
 *
 * @param {String} name
 * @api public
 */

function Command(name) {
  this.commands = [];
  this.options = [];
  this._execs = [];
  this._allowUnknownOption = false;
  this._args = [];
  this._name = name;
}

/**
 * Inherit from &#x60;EventEmitter.prototype&#x60;.
 */

Command.prototype.__proto__ = EventEmitter.prototype;

/**
 * Add command &#x60;name&#x60;.
 *
 * The &#x60;.action()&#x60; callback is invoked when the
 * command &#x60;name&#x60; is specified via __ARGV__,
 * and the remaining arguments are applied to the
 * function for access.
 *
 * When the &#x60;name&#x60; is &quot;*&quot; an un-matched command
 * will be passed as the first arg, followed by
 * the rest of __ARGV__ remaining.
 *
 * Examples:
 *
 *      program
 *        .version(&#x27;0.0.1&#x27;)
 *        .option(&#x27;-C, --chdir &lt;path&gt;&#x27;, &#x27;change the working directory&#x27;)
 *        .option(&#x27;-c, --config &lt;path&gt;&#x27;, &#x27;set config path. defaults to ./deploy.conf&#x27;)
 *        .option(&#x27;-T, --no-tests&#x27;, &#x27;ignore test hook&#x27;)
 *
 *      program
 *        .command(&#x27;setup&#x27;)
 *        .description(&#x27;run remote setup commands&#x27;)
 *        .action(function() {
 *          console.log(&#x27;setup&#x27;);
 *        });
 *
 *      program
 *        .command(&#x27;exec &lt;cmd&gt;&#x27;)
 *        .description(&#x27;run the given remote command&#x27;)
 *        .action(function(cmd) {
 *          console.log(&#x27;exec &quot;%s&quot;&#x27;, cmd);
 *        });
 *
 *      program
 *        .command(&#x27;teardown &lt;dir&gt; [otherDirs...]&#x27;)
 *        .description(&#x27;run teardown commands&#x27;)
 *        .action(function(dir, otherDirs) {
 *          console.log(&#x27;dir &quot;%s&quot;&#x27;, dir);
 *          if (otherDirs) {
 *            otherDirs.forEach(function (oDir) {
 *              console.log(&#x27;dir &quot;%s&quot;&#x27;, oDir);
 *            });
 *          }
 *        });
 *
 *      program
 *        .command(&#x27;*&#x27;)
 *        .description(&#x27;deploy the given env&#x27;)
 *        .action(function(env) {
 *          console.log(&#x27;deploying &quot;%s&quot;&#x27;, env);
 *        });
 *
 *      program.parse(process.argv);
  *
 * @param {String} name
 * @param {String} [desc] for git-style sub-commands
 * @return {Command} the new command
 * @api public
 */

Command.prototype.command = function(name, desc, opts) {
  opts = opts || {};
  var args = name.split(/ +/);
  var cmd = new Command(args.shift());

  if (desc) {
    cmd.description(desc);
    this.executables = true;
    this._execs[cmd._name] = true;
  }

  cmd._noHelp = !!opts.noHelp;
  this.commands.push(cmd);
  cmd.parseExpectedArgs(args);
  cmd.parent = this;

  if (desc) return this;
  return cmd;
};

/**
 * Define argument syntax for the top-level command.
 *
 * @api public
 */

Command.prototype.arguments = function (desc) {
  return this.parseExpectedArgs(desc.split(/ +/));
}

/**
 * Add an implicit &#x60;help [cmd]&#x60; subcommand
 * which invokes &#x60;--help&#x60; for the given command.
 *
 * @api private
 */

Command.prototype.addImplicitHelpCommand = function() {
  this.command(&#x27;help [cmd]&#x27;, &#x27;display help for [cmd]&#x27;);
};

/**
 * Parse expected &#x60;args&#x60;.
 *
 * For example &#x60;[&quot;[type]&quot;]&#x60; becomes &#x60;[{ required: false, name: &#x27;type&#x27; }]&#x60;.
 *
 * @param {Array} args
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.parseExpectedArgs = function(args) {
  if (!args.length) return;
  var self = this;
  args.forEach(function(arg) {
    var argDetails = {
      required: false,
      name: &#x27;&#x27;,
      variadic: false
    };

    switch (arg[0]) {
      case &#x27;&lt;&#x27;:
        argDetails.required = true;
        argDetails.name = arg.slice(1, -1);
        break;
      case &#x27;[&#x27;:
        argDetails.name = arg.slice(1, -1);
        break;
    }

    if (argDetails.name.length &gt; 3 &amp;&amp; argDetails.name.slice(-3) === &#x27;...&#x27;) {
      argDetails.variadic = true;
      argDetails.name = argDetails.name.slice(0, -3);
    }
    if (argDetails.name) {
      self._args.push(argDetails);
    }
  });
  return this;
};

/**
 * Register callback &#x60;fn&#x60; for the command.
 *
 * Examples:
 *
 *      program
 *        .command(&#x27;help&#x27;)
 *        .description(&#x27;display verbose help&#x27;)
 *        .action(function() {
 *           // output help here
 *        });
 *
 * @param {Function} fn
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.action = function(fn) {
  var self = this;
  var listener = function(args, unknown) {
    // Parse any so-far unknown options
    args = args || [];
    unknown = unknown || [];

    var parsed = self.parseOptions(unknown);

    // Output help if necessary
    outputHelpIfNecessary(self, parsed.unknown);

    // If there are still any unknown options, then we simply
    // die, unless someone asked for help, in which case we give it
    // to them, and then we die.
    if (parsed.unknown.length &gt; 0) {
      self.unknownOption(parsed.unknown[0]);
    }

    // Leftover arguments need to be pushed back. Fixes issue #56
    if (parsed.args.length) args = parsed.args.concat(args);

    self._args.forEach(function(arg, i) {
      if (arg.required &amp;&amp; null == args[i]) {
        self.missingArgument(arg.name);
      } else if (arg.variadic) {
        if (i !== self._args.length - 1) {
          self.variadicArgNotLast(arg.name);
        }

        args[i] = args.splice(i);
      }
    });

    // Always append ourselves to the end of the arguments,
    // to make sure we match the number of arguments the user
    // expects
    if (self._args.length) {
      args[self._args.length] = self;
    } else {
      args.push(self);
    }

    fn.apply(self, args);
  };
  var parent = this.parent || this;
  var name = parent === this ? &#x27;*&#x27; : this._name;
  parent.on(name, listener);
  if (this._alias) parent.on(this._alias, listener);
  return this;
};

/**
 * Define option with &#x60;flags&#x60;, &#x60;description&#x60; and optional
 * coercion &#x60;fn&#x60;.
 *
 * The &#x60;flags&#x60; string should contain both the short and long flags,
 * separated by comma, a pipe or space. The following are all valid
 * all will output this way when &#x60;--help&#x60; is used.
 *
 *    &quot;-p, --pepper&quot;
 *    &quot;-p|--pepper&quot;
 *    &quot;-p --pepper&quot;
 *
 * Examples:
 *
 *     // simple boolean defaulting to false
 *     program.option(&#x27;-p, --pepper&#x27;, &#x27;add pepper&#x27;);
 *
 *     --pepper
 *     program.pepper
 *     // =&gt; Boolean
 *
 *     // simple boolean defaulting to true
 *     program.option(&#x27;-C, --no-cheese&#x27;, &#x27;remove cheese&#x27;);
 *
 *     program.cheese
 *     // =&gt; true
 *
 *     --no-cheese
 *     program.cheese
 *     // =&gt; false
 *
 *     // required argument
 *     program.option(&#x27;-C, --chdir &lt;path&gt;&#x27;, &#x27;change the working directory&#x27;);
 *
 *     --chdir /tmp
 *     program.chdir
 *     // =&gt; &quot;/tmp&quot;
 *
 *     // optional argument
 *     program.option(&#x27;-c, --cheese [type]&#x27;, &#x27;add cheese [marble]&#x27;);
 *
 * @param {String} flags
 * @param {String} description
 * @param {Function|Mixed} fn or default
 * @param {Mixed} defaultValue
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.option = function(flags, description, fn, defaultValue) {
  var self = this
    , option = new Option(flags, description)
    , oname = option.name()
    , name = camelcase(oname);

  // default as 3rd arg
  if (typeof fn != &#x27;function&#x27;) {
    if (fn instanceof RegExp) {
      var regex = fn;
      fn = function(val, def) {
        var m = regex.exec(val);
        return m ? m[0] : def;
      }
    }
    else {
      defaultValue = fn;
      fn = null;
    }
  }

  // preassign default value only for --no-*, [optional], or &lt;required&gt;
  if (false == option.bool || option.optional || option.required) {
    // when --no-* we make sure default is true
    if (false == option.bool) defaultValue = true;
    // preassign only if we have a default
    if (undefined !== defaultValue) self[name] = defaultValue;
  }

  // register the option
  this.options.push(option);

  // when it&#x27;s passed assign the value
  // and conditionally invoke the callback
  this.on(oname, function(val) {
    // coercion
    if (null !== val &amp;&amp; fn) val = fn(val, undefined === self[name]
      ? defaultValue
      : self[name]);

    // unassigned or bool
    if (&#x27;boolean&#x27; == typeof self[name] || &#x27;undefined&#x27; == typeof self[name]) {
      // if no value, bool true, and we have a default, then use it!
      if (null == val) {
        self[name] = option.bool
          ? defaultValue || true
          : false;
      } else {
        self[name] = val;
      }
    } else if (null !== val) {
      // reassign
      self[name] = val;
    }
  });

  return this;
};

/**
 * Allow unknown options on the command line.
 *
 * @param {Boolean} arg if &#x60;true&#x60; or omitted, no error will be thrown
 * for unknown options.
 * @api public
 */
Command.prototype.allowUnknownOption = function(arg) {
    this._allowUnknownOption = arguments.length === 0 || arg;
    return this;
};

/**
 * Parse &#x60;argv&#x60;, settings options and invoking commands when defined.
 *
 * @param {Array} argv
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.parse = function(argv) {
  // implicit help
  if (this.executables) this.addImplicitHelpCommand();

  // store raw args
  this.rawArgs = argv;

  // guess name
  this._name = this._name || basename(argv[1], &#x27;.js&#x27;);

  // github-style sub-commands with no sub-command
  if (this.executables &amp;&amp; argv.length &lt; 3) {
    // this user needs help
    argv.push(&#x27;--help&#x27;);
  }

  // process argv
  var parsed = this.parseOptions(this.normalize(argv.slice(2)));
  var args = this.args = parsed.args;

  var result = this.parseArgs(this.args, parsed.unknown);

  // executable sub-commands
  var name = result.args[0];
  if (this._execs[name] &amp;&amp; typeof this._execs[name] != &quot;function&quot;) {
    return this.executeSubCommand(argv, args, parsed.unknown);
  }

  return result;
};

/**
 * Execute a sub-command executable.
 *
 * @param {Array} argv
 * @param {Array} args
 * @param {Array} unknown
 * @api private
 */

Command.prototype.executeSubCommand = function(argv, args, unknown) {
  args = args.concat(unknown);

  if (!args.length) this.help();
  if (&#x27;help&#x27; == args[0] &amp;&amp; 1 == args.length) this.help();

  // &lt;cmd&gt; --help
  if (&#x27;help&#x27; == args[0]) {
    args[0] = args[1];
    args[1] = &#x27;--help&#x27;;
  }

  // executable
  var f = argv[1];
  // name of the subcommand, link &#x60;pm-install&#x60;
  var bin = basename(f, &#x27;.js&#x27;) + &#x27;-&#x27; + args[0];


  // In case of globally installed, get the base dir where executable
  //  subcommand file should be located at
  var baseDir
    , link = readlink(f);

  // when symbolink is relative path
  if (link !== f &amp;&amp; link.charAt(0) !== &#x27;/&#x27;) {
    link = path.join(dirname(f), link)
  }
  baseDir = dirname(link);

  // prefer local &#x60;./&lt;bin&gt;&#x60; to bin in the $PATH
  var localBin = path.join(baseDir, bin);

  // whether bin file is a js script with explicit &#x60;.js&#x60; extension
  var isExplicitJS = false;
  if (exists(localBin + &#x27;.js&#x27;)) {
    bin = localBin + &#x27;.js&#x27;;
    isExplicitJS = true;
  } else if (exists(localBin)) {
    bin = localBin;
  }

  args = args.slice(1);

  var proc;
  if (process.platform !== &#x27;win32&#x27;) {
    if (isExplicitJS) {
      args.unshift(localBin);
      // add executable arguments to spawn
      args = (process.execArgv || []).concat(args);

      proc = spawn(&#x27;node&#x27;, args, { stdio: &#x27;inherit&#x27;, customFds: [0, 1, 2] });
    } else {
      proc = spawn(bin, args, { stdio: &#x27;inherit&#x27;, customFds: [0, 1, 2] });
    }
  } else {
    args.unshift(localBin);
    proc = spawn(process.execPath, args, { stdio: &#x27;inherit&#x27;});
  }

  proc.on(&#x27;close&#x27;, process.exit.bind(process));
  proc.on(&#x27;error&#x27;, function(err) {
    if (err.code == &quot;ENOENT&quot;) {
      console.error(&#x27;\n  %s(1) does not exist, try --help\n&#x27;, bin);
    } else if (err.code == &quot;EACCES&quot;) {
      console.error(&#x27;\n  %s(1) not executable. try chmod or run with root\n&#x27;, bin);
    }
    process.exit(1);
  });

  this.runningCommand = proc;
};

/**
 * Normalize &#x60;args&#x60;, splitting joined short flags. For example
 * the arg &quot;-abc&quot; is equivalent to &quot;-a -b -c&quot;.
 * This also normalizes equal sign and splits &quot;--abc=def&quot; into &quot;--abc def&quot;.
 *
 * @param {Array} args
 * @return {Array}
 * @api private
 */

Command.prototype.normalize = function(args) {
  var ret = []
    , arg
    , lastOpt
    , index;

  for (var i = 0, len = args.length; i &lt; len; ++i) {
    arg = args[i];
    if (i &gt; 0) {
      lastOpt = this.optionFor(args[i-1]);
    }

    if (arg === &#x27;--&#x27;) {
      // Honor option terminator
      ret = ret.concat(args.slice(i));
      break;
    } else if (lastOpt &amp;&amp; lastOpt.required) {
      ret.push(arg);
    } else if (arg.length &gt; 1 &amp;&amp; &#x27;-&#x27; == arg[0] &amp;&amp; &#x27;-&#x27; != arg[1]) {
      arg.slice(1).split(&#x27;&#x27;).forEach(function(c) {
        ret.push(&#x27;-&#x27; + c);
      });
    } else if (/^--/.test(arg) &amp;&amp; ~(index = arg.indexOf(&#x27;=&#x27;))) {
      ret.push(arg.slice(0, index), arg.slice(index + 1));
    } else {
      ret.push(arg);
    }
  }

  return ret;
};

/**
 * Parse command &#x60;args&#x60;.
 *
 * When listener(s) are available those
 * callbacks are invoked, otherwise the &quot;*&quot;
 * event is emitted and those actions are invoked.
 *
 * @param {Array} args
 * @return {Command} for chaining
 * @api private
 */

Command.prototype.parseArgs = function(args, unknown) {
  var name;

  if (args.length) {
    name = args[0];
    if (this.listeners(name).length) {
      this.emit(args.shift(), args, unknown);
    } else {
      this.emit(&#x27;*&#x27;, args);
    }
  } else {
    outputHelpIfNecessary(this, unknown);

    // If there were no args and we have unknown options,
    // then they are extraneous and we need to error.
    if (unknown.length &gt; 0) {
      this.unknownOption(unknown[0]);
    }
  }

  return this;
};

/**
 * Return an option matching &#x60;arg&#x60; if any.
 *
 * @param {String} arg
 * @return {Option}
 * @api private
 */

Command.prototype.optionFor = function(arg) {
  for (var i = 0, len = this.options.length; i &lt; len; ++i) {
    if (this.options[i].is(arg)) {
      return this.options[i];
    }
  }
};

/**
 * Parse options from &#x60;argv&#x60; returning &#x60;argv&#x60;
 * void of these options.
 *
 * @param {Array} argv
 * @return {Array}
 * @api public
 */

Command.prototype.parseOptions = function(argv) {
  var args = []
    , len = argv.length
    , literal
    , option
    , arg;

  var unknownOptions = [];

  // parse options
  for (var i = 0; i &lt; len; ++i) {
    arg = argv[i];

    // literal args after --
    if (&#x27;--&#x27; == arg) {
      literal = true;
      continue;
    }

    if (literal) {
      args.push(arg);
      continue;
    }

    // find matching Option
    option = this.optionFor(arg);

    // option is defined
    if (option) {
      // requires arg
      if (option.required) {
        arg = argv[++i];
        if (null == arg) return this.optionMissingArgument(option);
        this.emit(option.name(), arg);
      // optional arg
      } else if (option.optional) {
        arg = argv[i+1];
        if (null == arg || (&#x27;-&#x27; == arg[0] &amp;&amp; &#x27;-&#x27; != arg)) {
          arg = null;
        } else {
          ++i;
        }
        this.emit(option.name(), arg);
      // bool
      } else {
        this.emit(option.name());
      }
      continue;
    }

    // looks like an option
    if (arg.length &gt; 1 &amp;&amp; &#x27;-&#x27; == arg[0]) {
      unknownOptions.push(arg);

      // If the next argument looks like it might be
      // an argument for this option, we pass it on.
      // If it isn&#x27;t, then it&#x27;ll simply be ignored
      if (argv[i+1] &amp;&amp; &#x27;-&#x27; != argv[i+1][0]) {
        unknownOptions.push(argv[++i]);
      }
      continue;
    }

    // arg
    args.push(arg);
  }

  return { args: args, unknown: unknownOptions };
};

/**
 * Return an object containing options as key-value pairs
 *
 * @return {Object}
 * @api public
 */
Command.prototype.opts = function() {
  var result = {}
    , len = this.options.length;

  for (var i = 0 ; i &lt; len; i++) {
    var key = camelcase(this.options[i].name());
    result[key] = key === &#x27;version&#x27; ? this._version : this[key];
  }
  return result;
};

/**
 * Argument &#x60;name&#x60; is missing.
 *
 * @param {String} name
 * @api private
 */

Command.prototype.missingArgument = function(name) {
  console.error();
  console.error(&quot;  error: missing required argument &#x60;%s&#x27;&quot;, name);
  console.error();
  process.exit(1);
};

/**
 * &#x60;Option&#x60; is missing an argument, but received &#x60;flag&#x60; or nothing.
 *
 * @param {String} option
 * @param {String} flag
 * @api private
 */

Command.prototype.optionMissingArgument = function(option, flag) {
  console.error();
  if (flag) {
    console.error(&quot;  error: option &#x60;%s&#x27; argument missing, got &#x60;%s&#x27;&quot;, option.flags, flag);
  } else {
    console.error(&quot;  error: option &#x60;%s&#x27; argument missing&quot;, option.flags);
  }
  console.error();
  process.exit(1);
};

/**
 * Unknown option &#x60;flag&#x60;.
 *
 * @param {String} flag
 * @api private
 */

Command.prototype.unknownOption = function(flag) {
  if (this._allowUnknownOption) return;
  console.error();
  console.error(&quot;  error: unknown option &#x60;%s&#x27;&quot;, flag);
  console.error();
  process.exit(1);
};

/**
 * Variadic argument with &#x60;name&#x60; is not the last argument as required.
 *
 * @param {String} name
 * @api private
 */

Command.prototype.variadicArgNotLast = function(name) {
  console.error();
  console.error(&quot;  error: variadic arguments must be last &#x60;%s&#x27;&quot;, name);
  console.error();
  process.exit(1);
};

/**
 * Set the program version to &#x60;str&#x60;.
 *
 * This method auto-registers the &quot;-V, --version&quot; flag
 * which will print the version number when passed.
 *
 * @param {String} str
 * @param {String} flags
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.version = function(str, flags) {
  if (0 == arguments.length) return this._version;
  this._version = str;
  flags = flags || &#x27;-V, --version&#x27;;
  this.option(flags, &#x27;output the version number&#x27;);
  this.on(&#x27;version&#x27;, function() {
    process.stdout.write(str + &#x27;\n&#x27;);
    process.exit(0);
  });
  return this;
};

/**
 * Set the description to &#x60;str&#x60;.
 *
 * @param {String} str
 * @return {String|Command}
 * @api public
 */

Command.prototype.description = function(str) {
  if (0 == arguments.length) return this._description;
  this._description = str;
  return this;
};

/**
 * Set an alias for the command
 *
 * @param {String} alias
 * @return {String|Command}
 * @api public
 */

Command.prototype.alias = function(alias) {
  if (0 == arguments.length) return this._alias;
  this._alias = alias;
  return this;
};

/**
 * Set / get the command usage &#x60;str&#x60;.
 *
 * @param {String} str
 * @return {String|Command}
 * @api public
 */

Command.prototype.usage = function(str) {
  var args = this._args.map(function(arg) {
    return humanReadableArgName(arg);
  });

  var usage = &#x27;[options]&#x27;
    + (this.commands.length ? &#x27; [command]&#x27; : &#x27;&#x27;)
    + (this._args.length ? &#x27; &#x27; + args.join(&#x27; &#x27;) : &#x27;&#x27;);

  if (0 == arguments.length) return this._usage || usage;
  this._usage = str;

  return this;
};

/**
 * Get the name of the command
 *
 * @param {String} name
 * @return {String|Command}
 * @api public
 */

Command.prototype.name = function() {
  return this._name;
};

/**
 * Return the largest option length.
 *
 * @return {Number}
 * @api private
 */

Command.prototype.largestOptionLength = function() {
  return this.options.reduce(function(max, option) {
    return Math.max(max, option.flags.length);
  }, 0);
};

/**
 * Return help for options.
 *
 * @return {String}
 * @api private
 */

Command.prototype.optionHelp = function() {
  var width = this.largestOptionLength();

  // Prepend the help information
  return [pad(&#x27;-h, --help&#x27;, width) + &#x27;  &#x27; + &#x27;output usage information&#x27;]
    .concat(this.options.map(function(option) {
      return pad(option.flags, width) + &#x27;  &#x27; + option.description;
      }))
    .join(&#x27;\n&#x27;);
};

/**
 * Return command help documentation.
 *
 * @return {String}
 * @api private
 */

Command.prototype.commandHelp = function() {
  if (!this.commands.length) return &#x27;&#x27;;

  var commands = this.commands.filter(function(cmd) {
    return !cmd._noHelp;
  }).map(function(cmd) {
    var args = cmd._args.map(function(arg) {
      return humanReadableArgName(arg);
    }).join(&#x27; &#x27;);

    return [
      cmd._name
        + (cmd._alias
          ? &#x27;|&#x27; + cmd._alias
          : &#x27;&#x27;)
        + (cmd.options.length
          ? &#x27; [options]&#x27;
          : &#x27;&#x27;)
        + &#x27; &#x27; + args
    , cmd.description()
    ];
  });

  var width = commands.reduce(function(max, command) {
    return Math.max(max, command[0].length);
  }, 0);

  return [
      &#x27;&#x27;
    , &#x27;  Commands:&#x27;
    , &#x27;&#x27;
    , commands.map(function(cmd) {
      return pad(cmd[0], width) + &#x27;  &#x27; + cmd[1];
    }).join(&#x27;\n&#x27;).replace(/^/gm, &#x27;    &#x27;)
    , &#x27;&#x27;
  ].join(&#x27;\n&#x27;);
};

/**
 * Return program help documentation.
 *
 * @return {String}
 * @api private
 */

Command.prototype.helpInformation = function() {
  var desc = [];
  if (this._description) {
    desc = [
      &#x27;  &#x27; + this._description
      , &#x27;&#x27;
    ];
  }

  var cmdName = this._name;
  if (this._alias) {
    cmdName = cmdName + &#x27;|&#x27; + this._alias;
  }
  var usage = [
    &#x27;&#x27;
    ,&#x27;  Usage: &#x27; + cmdName + &#x27; &#x27; + this.usage()
    , &#x27;&#x27;
  ];

  var cmds = [];
  var commandHelp = this.commandHelp();
  if (commandHelp) cmds = [commandHelp];

  var options = [
    &#x27;  Options:&#x27;
    , &#x27;&#x27;
    , &#x27;&#x27; + this.optionHelp().replace(/^/gm, &#x27;    &#x27;)
    , &#x27;&#x27;
    , &#x27;&#x27;
  ];

  return usage
    .concat(cmds)
    .concat(desc)
    .concat(options)
    .join(&#x27;\n&#x27;);
};

/**
 * Output help information for this command
 *
 * @api public
 */

Command.prototype.outputHelp = function() {
  process.stdout.write(this.helpInformation());
  this.emit(&#x27;--help&#x27;);
};

/**
 * Output help information and exit.
 *
 * @api public
 */

Command.prototype.help = function() {
  this.outputHelp();
  process.exit();
};

/**
 * Camel-case the given &#x60;flag&#x60;
 *
 * @param {String} flag
 * @return {String}
 * @api private
 */

function camelcase(flag) {
  return flag.split(&#x27;-&#x27;).reduce(function(str, word) {
    return str + word[0].toUpperCase() + word.slice(1);
  });
}

/**
 * Pad &#x60;str&#x60; to &#x60;width&#x60;.
 *
 * @param {String} str
 * @param {Number} width
 * @return {String}
 * @api private
 */

function pad(str, width) {
  var len = Math.max(0, width - str.length);
  return str + Array(len + 1).join(&#x27; &#x27;);
}

/**
 * Output help information if necessary
 *
 * @param {Command} command to output help for
 * @param {Array} array of options to search for -h or --help
 * @api private
 */

function outputHelpIfNecessary(cmd, options) {
  options = options || [];
  for (var i = 0; i &lt; options.length; i++) {
    if (options[i] == &#x27;--help&#x27; || options[i] == &#x27;-h&#x27;) {
      cmd.outputHelp();
      process.exit(0);
    }
  }
}

/**
 * Takes an argument an returns its human readable equivalent for help usage.
 *
 * @param {Object} arg
 * @return {String}
 * @api private
 */

function humanReadableArgName(arg) {
  var nameOutput = arg.name + (arg.variadic === true ? &#x27;...&#x27; : &#x27;&#x27;);

  return arg.required
    ? &#x27;&lt;&#x27; + nameOutput + &#x27;&gt;&#x27;
    : &#x27;[&#x27; + nameOutput + &#x27;]&#x27;
}

// for versions before node v0.8 when there weren&#x27;t &#x60;fs.existsSync&#x60;
function exists(file) {
  try {
    if (fs.statSync(file).isFile()) {
      return true;
    }
  } catch (e) {
    return false;
  }
}


    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
