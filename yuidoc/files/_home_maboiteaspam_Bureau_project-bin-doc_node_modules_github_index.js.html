<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>/home/maboiteaspam/Bureau/project-bin-doc/node_modules/github/index.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Cluc.html">Cluc</a></li>
                                <li><a href="../classes/ClucAnswer.html">ClucAnswer</a></li>
                                <li><a href="../classes/ClucChildProcess.html">ClucChildProcess</a></li>
                                <li><a href="../classes/ClucConfirm.html">ClucConfirm</a></li>
                                <li><a href="../classes/ClucContext.html">ClucContext</a></li>
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/ClucDieOnError.html">ClucDieOnError</a></li>
                                <li><a href="../classes/ClucDisplay.html">ClucDisplay</a></li>
                                <li><a href="../classes/ClucMustNot.html">ClucMustNot</a></li>
                                <li><a href="../classes/ClucProgress.html">ClucProgress</a></li>
                                <li><a href="../classes/ClucRule.html">ClucRule</a></li>
                                <li><a href="../classes/ClucSpin.html">ClucSpin</a></li>
                                <li><a href="../classes/ClucSpinUntil.html">ClucSpinUntil</a></li>
                                <li><a href="../classes/ClucSsh.html">ClucSsh</a></li>
                                <li><a href="../classes/ClucSSHContext.html">ClucSSHContext</a></li>
                                <li><a href="../classes/ClucSuccess.html">ClucSuccess</a></li>
                                <li><a href="../classes/ClucWarn.html">ClucWarn</a></li>
                                <li><a href="../classes/ClucWatch.html">ClucWatch</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: /home/maboiteaspam/Bureau/project-bin-doc/node_modules/github/index.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&quot;use strict&quot;;

var error = require(&quot;./error&quot;);
var fs = require(&quot;fs&quot;);
var mime = require(&quot;mime&quot;);
var Util = require(&quot;./util&quot;);
var Url = require(&quot;url&quot;);

/** section: github
 * class Client
 *
 *  Copyright 2012 Cloud9 IDE, Inc.
 *
 *  This product includes software developed by
 *  Cloud9 IDE, Inc (http://c9.io).
 *
 *  Author: Mike de Boer &lt;mike@c9.io&gt;
 *
 *  [[Client]] can load any version of the [[github]] client API, with the
 *  requirement that a valid routes.json definition file is present in the
 *  &#x60;api/[VERSION]&#x60; directory and that the routes found in this file are
 *  implemented as well.
 *
 *  Upon instantiation of the [[Client]] class, the routes.json file is loaded
 *  from the API version specified in the configuration and, parsed and from it
 *  the routes for HTTP requests are extracted. For each HTTP endpoint to the
 *  HTTP server, a method is generated which accepts a Javascript Object
 *  with parameters and an optional callback to be invoked when the API request
 *  returns from the server or when the parameters could not be validated.
 *
 *  When an HTTP endpoint is processed and a method is generated as described
 *  above, [[Client]] also sets up parameter validation with the rules as
 *  defined in the routes.json. A full example that illustrates how this works
 *  is shown below:
 *
 *  ##### Example
 *
 *  First, we look at a listing of a sample routes.json routes definition file:
 *
 *      {
 *          &quot;defines&quot;: {
 *              &quot;constants&quot;: {
 *                  &quot;name&quot;: &quot;Github&quot;,
 *                  &quot;description&quot;: &quot;A Node.JS module, which provides an object oriented wrapper for the GitHub v3 API.&quot;,
 *                  &quot;protocol&quot;: &quot;https&quot;,
 *                  &quot;host&quot;: &quot;api.github.com&quot;,
 *                  &quot;port&quot;: 443,
 *                  &quot;dateFormat&quot;: &quot;YYYY-MM-DDTHH:MM:SSZ&quot;,
 *                  &quot;requestFormat&quot;: &quot;json&quot;
 *              },
 *              &quot;response-headers&quot;: [
 *                  &quot;X-RateLimit-Limit&quot;,
 *                  &quot;X-RateLimit-Remaining&quot;,
 *                  &quot;Link&quot;
 *              ],
 *              &quot;params&quot;: {
 *                  &quot;files&quot;: {
 *                      &quot;type&quot;: &quot;Json&quot;,
 *                      &quot;required&quot;: true,
 *                      &quot;validation&quot;: &quot;&quot;,
 *                      &quot;invalidmsg&quot;: &quot;&quot;,
 *                      &quot;description&quot;: &quot;Files that make up this gist. The key of which should be a required string filename and the value another required hash with parameters: &#x27;content&#x27;&quot;
 *                  },
 *                  &quot;user&quot;: {
 *                      &quot;type&quot;: &quot;String&quot;,
 *                      &quot;required&quot;: true,
 *                      &quot;validation&quot;: &quot;&quot;,
 *                      &quot;invalidmsg&quot;: &quot;&quot;,
 *                      &quot;description&quot;: &quot;&quot;
 *                  },
 *                  &quot;description&quot;: {
 *                      &quot;type&quot;: &quot;String&quot;,
 *                      &quot;required&quot;: false,
 *                      &quot;validation&quot;: &quot;&quot;,
 *                      &quot;invalidmsg&quot;: &quot;&quot;,
 *                      &quot;description&quot;: &quot;&quot;
 *                  },
 *                  &quot;page&quot;: {
 *                      &quot;type&quot;: &quot;Number&quot;,
 *                      &quot;required&quot;: false,
 *                      &quot;validation&quot;: &quot;^[0-9]+$&quot;,
 *                      &quot;invalidmsg&quot;: &quot;&quot;,
 *                      &quot;description&quot;: &quot;Page number of the results to fetch.&quot;
 *                  },
 *                  &quot;per_page&quot;: {
 *                      &quot;type&quot;: &quot;Number&quot;,
 *                      &quot;required&quot;: false,
 *                      &quot;validation&quot;: &quot;^[0-9]+$&quot;,
 *                      &quot;invalidmsg&quot;: &quot;&quot;,
 *                      &quot;description&quot;: &quot;A custom page size up to 100. Default is 30.&quot;
 *                  }
 *              }
 *          },
 *
 *          &quot;gists&quot;: {
 *              &quot;get-from-user&quot;: {
 *                  &quot;url&quot;: &quot;:user/gists&quot;,
 *                  &quot;method&quot;: &quot;GET&quot;,
 *                  &quot;params&quot;: {
 *                      &quot;$user&quot;: null,
 *                      &quot;$page&quot;: null,
 *                      &quot;$per_page&quot;: null
 *                  }
 *              },
 *
 *              &quot;create&quot;: {
 *                  &quot;url&quot;: &quot;/gists&quot;,
 *                  &quot;method&quot;: &quot;POST&quot;,
 *                  &quot;params&quot;: {
 *                      &quot;$description&quot;: null,
 *                      &quot;public&quot;: {
 *                          &quot;type&quot;: &quot;Boolean&quot;,
 *                          &quot;required&quot;: true,
 *                          &quot;validation&quot;: &quot;&quot;,
 *                          &quot;invalidmsg&quot;: &quot;&quot;,
 *                          &quot;description&quot;: &quot;&quot;
 *                      },
 *                      &quot;$files&quot;: null
 *                  }
 *              }
 *          }
 *       }
 *
 *  You probably noticed that the definition is quite verbose and the decision
 *  for its design was made to be verbose whilst still allowing for basic variable
 *  definitions and substitions for request parameters.
 *
 *  There are two sections; &#x27;defines&#x27; and &#x27;gists&#x27; in this example.
 *
 *  The &#x60;defines&#x60; section contains a list of &#x60;constants&#x60; that will be used by the
 *  [[Client]] to make requests to the right URL that hosts the API.
 *  The &#x60;gists&#x60; section defines the endpoints for calls to the API server, for
 *  gists specifically in this example, but the other API sections are defined in
 *  the exact same way.
 *  These definitions are parsed and methods are created that the client can call
 *  to make an HTTP request to the server.
 *  there is one endpoint defined: .
 *  In this example, the endpoint &#x60;gists/get-from-user&#x60; will be exposed as a member
 *  on the [[Client]] object and may be invoked with
 *
 *      client.getFromUser({
 *          &quot;user&quot;: &quot;bob&quot;
 *      }, function(err, ret) {
 *          // do something with the result here.
 *      });
 *
 *      // or to fetch a specfic page:
 *      client.getFromUser({
 *          &quot;user&quot;: &quot;bob&quot;,
 *          &quot;page&quot;: 2,
 *          &quot;per_page&quot;: 100
 *      }, function(err, ret) {
 *          // do something with the result here.
 *      });
 *
 *  All the parameters as specified in the Object that is passed to the function
 *  as first argument, will be validated according to the rules in the &#x60;params&#x60;
 *  block of the route definition.
 *  Thus, in the case of the &#x60;user&#x60; parameter, according to the definition in
 *  the &#x60;params&#x60; block, it&#x27;s a variable that first needs to be looked up in the
 *  &#x60;params&#x60; block of the &#x60;defines&#x60; section (at the top of the JSON file). Params
 *  that start with a &#x60;$&#x60; sign will be substituted with the param with the same
 *  name from the &#x60;defines/params&#x60; section.
 *  There we see that it is a required parameter (needs to hold a value). In other
 *  words, if the validation requirements are not met, an HTTP error is passed as
 *  first argument of the callback.
 *
 *  Implementation Notes: the &#x60;method&#x60; is NOT case sensitive, whereas &#x60;url&#x60; is.
 *  The &#x60;url&#x60; parameter also supports denoting parameters inside it as follows:
 *
 *      &quot;get-from-user&quot;: {
 *          &quot;url&quot;: &quot;:user/gists&quot;,
 *          &quot;method&quot;: &quot;GET&quot;
 *          ...
 *      }
 **/
var Client = module.exports = function(config) {
    config.headers = config.headers || {};
    this.config = config;
    this.debug = Util.isTrue(config.debug);

    this.version = config.version;
    var cls = require(&quot;./api/v&quot; + this.version);
    this[this.version] = new cls(this);

    var pathPrefix = &quot;&quot;;
    // Check if a prefix is passed in the config and strip any leading or trailing slashes from it.
    if (typeof config.pathPrefix == &quot;string&quot;) {
        pathPrefix = &quot;/&quot; + config.pathPrefix.replace(/(^[\/]+|[\/]+$)/g, &quot;&quot;);
        this.config.pathPrefix = pathPrefix;
    }

    this.setupRoutes();
};

(function() {
    /**
     *  Client#setupRoutes() -&gt; null
     *
     *  Configures the routes as defined in a routes.json file of an API version
     *
     *  [[Client#setupRoutes]] is invoked by the constructor, takes the
     *  contents of the JSON document that contains the definitions of all the
     *  available API routes and iterates over them.
     *
     *  It first recurses through each definition block until it reaches an API
     *  endpoint. It knows that an endpoint is found when the &#x60;url&#x60; and &#x60;param&#x60;
     *  definitions are found as a direct member of a definition block.
     *  Then the availability of an implementation by the API is checked; if it&#x27;s
     *  not present, this means that a portion of the API as defined in the routes.json
     *  file is not implemented properly, thus an exception is thrown.
     *  After this check, a method is attached to the [[Client]] instance
     *  and becomes available for use. Inside this method, the parameter validation
     *  and typecasting is done, according to the definition of the parameters in
     *  the &#x60;params&#x60; block, upon invocation.
     *
     *  This mechanism ensures that the handlers ALWAYS receive normalized data
     *  that is of the correct format and type. JSON parameters are parsed, Strings
     *  are trimmed, Numbers and Floats are casted and checked for NaN after that.
     *
     *  Note: Query escaping for usage with SQL products is something that can be
     *  implemented additionally by adding an additional parameter type.
     **/
    this.setupRoutes = function() {
        var self = this;
        var api = this[this.version];
        var routes = api.routes;
        var defines = routes.defines;
        this.constants = defines.constants;
        this.requestHeaders = defines[&quot;request-headers&quot;].map(function(header) {
            return header.toLowerCase();
        });
        delete routes.defines;

        function trim(s) {
            if (typeof s != &quot;string&quot;)
                return s;
            return s.replace(/^[\s\t\r\n]+/, &quot;&quot;).replace(/[\s\t\r\n]+$/, &quot;&quot;);
        }

        function parseParams(msg, paramsStruct) {
            var params = Object.keys(paramsStruct);
            var paramName, def, value, type;
            for (var i = 0, l = params.length; i &lt; l; ++i) {
                paramName = params[i];
                if (paramName.charAt(0) == &quot;$&quot;) {
                    paramName = paramName.substr(1);
                    if (!defines.params[paramName]) {
                        throw new error.BadRequest(&quot;Invalid variable parameter name substitution; param &#x27;&quot; +
                            paramName + &quot;&#x27; not found in defines block&quot;, &quot;fatal&quot;);
                    }
                    else {
                        def = paramsStruct[paramName] = defines.params[paramName];
                        delete paramsStruct[&quot;$&quot; + paramName];
                    }
                }
                else
                    def = paramsStruct[paramName];

                value = trim(msg[paramName]);
                if (typeof value != &quot;boolean&quot; &amp;&amp; !value) {
                    // we don&#x27;t need to validation for undefined parameter values
                    // that are not required.
                    if (!def.required || (def[&quot;allow-empty&quot;] &amp;&amp; value === &quot;&quot;))
                        continue;
                    throw new error.BadRequest(&quot;Empty value for parameter &#x27;&quot; +
                        paramName + &quot;&#x27;: &quot; + value);
                }

                // validate the value and type of parameter:
                if (def.validation) {
                    if (!new RegExp(def.validation).test(value)) {
                        throw new error.BadRequest(&quot;Invalid value for parameter &#x27;&quot; +
                            paramName + &quot;&#x27;: &quot; + value);
                    }
                }

                if (def.type) {
                    type = def.type.toLowerCase();
                    if (type == &quot;number&quot;) {
                        value = parseInt(value, 10);
                        if (isNaN(value)) {
                            throw new error.BadRequest(&quot;Invalid value for parameter &#x27;&quot; +
                                paramName + &quot;&#x27;: &quot; + msg[paramName] + &quot; is NaN&quot;);
                        }
                    }
                    else if (type == &quot;float&quot;) {
                        value = parseFloat(value);
                        if (isNaN(value)) {
                            throw new error.BadRequest(&quot;Invalid value for parameter &#x27;&quot; +
                                paramName + &quot;&#x27;: &quot; + msg[paramName] + &quot; is NaN&quot;);
                        }
                    }
                    else if (type == &quot;json&quot;) {
                        if (typeof value == &quot;string&quot;) {
                            try {
                                value = JSON.parse(value);
                            }
                            catch(ex) {
                                throw new error.BadRequest(&quot;JSON parse error of value for parameter &#x27;&quot; +
                                    paramName + &quot;&#x27;: &quot; + value);
                            }
                        }
                    }
                    else if (type == &quot;date&quot;) {
                        value = new Date(value);
                    }
                }
                msg[paramName] = value;
            }
        }

        function prepareApi(struct, baseType) {
            if (!baseType)
                baseType = &quot;&quot;;
            Object.keys(struct).forEach(function(routePart) {
                var block = struct[routePart];
                if (!block)
                    return;
                var messageType = baseType + &quot;/&quot; + routePart;
                if (block.url &amp;&amp; block.params) {
                    // we ended up at an API definition part!
                    var endPoint = messageType.replace(/^[\/]+/g, &quot;&quot;);
                    var parts = messageType.split(&quot;/&quot;);
                    var section = Util.toCamelCase(parts[1].toLowerCase());
                    parts.splice(0, 2);
                    var funcName = Util.toCamelCase(parts.join(&quot;-&quot;));

                    if (!api[section]) {
                        throw new Error(&quot;Unsupported route section, not implemented in version &quot; +
                            self.version + &quot; for route &#x27;&quot; + endPoint + &quot;&#x27; and block: &quot; +
                            JSON.stringify(block));
                    }

                    if (!api[section][funcName]) {
                        if (self.debug)
                            Util.log(&quot;Tried to call &quot; + funcName);
                        throw new Error(&quot;Unsupported route, not implemented in version &quot; +
                            self.version + &quot; for route &#x27;&quot; + endPoint + &quot;&#x27; and block: &quot; +
                            JSON.stringify(block));
                    }

                    if (!self[section]) {
                        self[section] = {};
                        // add a utility function &#x27;getFooApi()&#x27;, which returns the
                        // section to which functions are attached.
                        self[Util.toCamelCase(&quot;get-&quot; + section + &quot;-api&quot;)] = function() {
                            return self[section];
                        };
                    }

                    self[section][funcName] = function(msg, callback) {
                        try {
                            parseParams(msg, block.params);
                        }
                        catch (ex) {
                            // when the message was sent to the client, we can
                            // reply with the error directly.
                            api.sendError(ex, block, msg, callback);
                            if (self.debug)
                                Util.log(ex.message, &quot;fatal&quot;);
                            // on error, there&#x27;s no need to continue.
                            return;
                        }

                        api[section][funcName].call(api, msg, block, callback);
                    };
                }
                else {
                    // recurse into this block next:
                    prepareApi(block, messageType);
                }
            });
        }

        prepareApi(routes);
    };

    /**
     *  Client#authenticate(options) -&gt; null
     *      - options (Object): Object containing the authentication type and credentials
     *          - type (String): One of the following: &#x60;basic&#x60; or &#x60;oauth&#x60;
     *          - username (String): Github username
     *          - password (String): Password to your account
     *          - token (String): OAuth2 token
     *
     *  Set an authentication method to have access to protected resources.
     *
     *  ##### Example
     *
     *      // basic
     *      github.authenticate({
     *          type: &quot;basic&quot;,
     *          username: &quot;mikedeboertest&quot;,
     *          password: &quot;test1324&quot;
     *      });
     *
     *      // or oauth
     *      github.authenticate({
     *          type: &quot;oauth&quot;,
     *          token: &quot;e5a4a27487c26e571892846366de023349321a73&quot;
     *      });
     *
     *      // or oauth key/ secret
     *      github.authenticate({
     *          type: &quot;oauth&quot;,
     *          key: &quot;clientID&quot;,
     *          secret: &quot;clientSecret&quot;
     *      });
     *
     *      // or token
     *      github.authenticate({
     *          type: &quot;token&quot;,
     *          token: &quot;userToken&quot;,
     *      });
     **/
    this.authenticate = function(options) {
        if (!options) {
            this.auth = false;
            return;
        }
        if (!options.type || &quot;basic|oauth|client|token&quot;.indexOf(options.type) === -1)
            throw new Error(&quot;Invalid authentication type, must be &#x27;basic&#x27;, &#x27;oauth&#x27; or &#x27;client&#x27;&quot;);
        if (options.type == &quot;basic&quot; &amp;&amp; (!options.username || !options.password))
            throw new Error(&quot;Basic authentication requires both a username and password to be set&quot;);
        if (options.type == &quot;oauth&quot;) {
            if (!options.token &amp;&amp; !(options.key &amp;&amp; options.secret))
                throw new Error(&quot;OAuth2 authentication requires a token or key &amp; secret to be set&quot;);
        }
        if (options.type == &quot;token&quot; &amp;&amp; !options.token)
            throw new Error(&quot;Token authentication requires a token to be set&quot;);

        this.auth = options;
    };

    function getPageLinks(link) {
        if (typeof link == &quot;object&quot; &amp;&amp; (link.link || link.meta.link))
            link = link.link || link.meta.link;

        var links = {};
        if (typeof link != &quot;string&quot;)
            return links;

        // link format:
        // &#x27;&lt;https://api.github.com/users/aseemk/followers?page=2&gt;; rel=&quot;next&quot;, &lt;https://api.github.com/users/aseemk/followers?page=2&gt;; rel=&quot;last&quot;&#x27;
        link.replace(/&lt;([^&gt;]*)&gt;;\s*rel=&quot;([\w]*)\&quot;/g, function(m, uri, type) {
            links[type] = uri;
        });
        return links;
    }

    /**
     *  Client#hasNextPage(link) -&gt; null
     *      - link (mixed): response of a request or the contents of the Link header
     *
     *  Check if a request result contains a link to the next page
     **/
    this.hasNextPage = function(link) {
        return getPageLinks(link).next;
    };

    /**
     *  Client#hasPreviousPage(link) -&gt; null
     *      - link (mixed): response of a request or the contents of the Link header
     *
     *  Check if a request result contains a link to the previous page
     **/
    this.hasPreviousPage = function(link) {
        return getPageLinks(link).prev;
    };

    /**
     *  Client#hasLastPage(link) -&gt; null
     *      - link (mixed): response of a request or the contents of the Link header
     *
     *  Check if a request result contains a link to the last page
     **/
    this.hasLastPage = function(link) {
        return getPageLinks(link).last;
    };

    /**
     *  Client#hasFirstPage(link) -&gt; null
     *      - link (mixed): response of a request or the contents of the Link header
     *
     *  Check if a request result contains a link to the first page
     **/
    this.hasFirstPage = function(link) {
        return getPageLinks(link).first;
    };

    function getPage(link, which, callback) {
        var url = getPageLinks(link)[which];
        if (!url)
            return callback(new error.NotFound(&quot;No &quot; + which + &quot; page found&quot;));

        var api = this[this.version];
        var parsedUrl = Url.parse(url, true);
        var block = {
            url: parsedUrl.pathname,
            method: &quot;GET&quot;,
            params: parsedUrl.query
        };
        this.httpSend(parsedUrl.query, block, function(err, res) {
            if (err)
                return api.sendError(err, null, parsedUrl.query, callback);

            var ret;
            try {
                ret = res.data;
                var contentType = res.headers[&quot;content-type&quot;];
                if (contentType &amp;&amp; contentType.indexOf(&quot;application/json&quot;) !== -1)
                    ret = JSON.parse(ret);
            }
            catch (ex) {
                if (callback)
                    callback(new error.InternalServerError(ex.message), res);
                return;
            }

            if (!ret)
                ret = {};
            if (typeof ret == &quot;object&quot;) {
                if (!ret.meta)
                    ret.meta = {};
                [&quot;x-ratelimit-limit&quot;, &quot;x-ratelimit-remaining&quot;, &quot;link&quot;].forEach(function(header) {
                    if (res.headers[header])
                        ret.meta[header] = res.headers[header];
                });
            }

            if (callback)
                callback(null, ret);
        });
    }

    /**
     *  Client#getNextPage(link, callback) -&gt; null
     *      - link (mixed): response of a request or the contents of the Link header
     *      - callback (Function): function to call when the request is finished with an error as first argument and result data as second argument.
     *
     *  Get the next page, based on the contents of the &#x60;Link&#x60; header
     **/
    this.getNextPage = function(link, callback) {
        getPage.call(this, link, &quot;next&quot;, callback);
    };

    /**
     *  Client#getPreviousPage(link, callback) -&gt; null
     *      - link (mixed): response of a request or the contents of the Link header
     *      - callback (Function): function to call when the request is finished with an error as first argument and result data as second argument.
     *
     *  Get the previous page, based on the contents of the &#x60;Link&#x60; header
     **/
    this.getPreviousPage = function(link, callback) {
        getPage.call(this, link, &quot;prev&quot;, callback);
    };

    /**
     *  Client#getLastPage(link, callback) -&gt; null
     *      - link (mixed): response of a request or the contents of the Link header
     *      - callback (Function): function to call when the request is finished with an error as first argument and result data as second argument.
     *
     *  Get the last page, based on the contents of the &#x60;Link&#x60; header
     **/
    this.getLastPage = function(link, callback) {
        getPage.call(this, link, &quot;last&quot;, callback);
    };

    /**
     *  Client#getFirstPage(link, callback) -&gt; null
     *      - link (mixed): response of a request or the contents of the Link header
     *      - callback (Function): function to call when the request is finished with an error as first argument and result data as second argument.
     *
     *  Get the first page, based on the contents of the &#x60;Link&#x60; header
     **/
    this.getFirstPage = function(link, callback) {
        getPage.call(this, link, &quot;first&quot;, callback);
    };

    function getRequestFormat(hasBody, block) {
        if (hasBody)
            return block.requestFormat || this.constants.requestFormat;

        return &quot;query&quot;;
    }

    function getQueryAndUrl(msg, def, format, config) {
        var url = def.url;
        if (config.pathPrefix &amp;&amp; url.indexOf(config.pathPrefix) !== 0) {
            url = config.pathPrefix + def.url;
        }
        var ret = {
            query: format == &quot;json&quot; ? {} : format == &quot;raw&quot; ? msg.data : []
        };
        if (!def || !def.params) {
            ret.url = url;
            return ret;
        }

        Object.keys(def.params).forEach(function(paramName) {
            paramName = paramName.replace(/^[$]+/, &quot;&quot;);
            if (!(paramName in msg))
                return;

            var isUrlParam = url.indexOf(&quot;:&quot; + paramName) !== -1;
            var valFormat = isUrlParam || format != &quot;json&quot; ? &quot;query&quot; : format;
            var val;
            if (valFormat != &quot;json&quot;) {
                if (typeof msg[paramName] == &quot;object&quot;) {
                    try {
                        msg[paramName] = JSON.stringify(msg[paramName]);
                        val = encodeURIComponent(msg[paramName]);
                    }
                    catch (ex) {
                        return Util.log(&quot;httpSend: Error while converting object to JSON: &quot;
                            + (ex.message || ex), &quot;error&quot;);
                    }
                }
                else if (def.params[paramName] &amp;&amp; def.params[paramName].combined) {
                    // Check if this is a combined (search) string.
                    val = msg[paramName].split(/[\s\t\r\n]*\+[\s\t\r\n]*/)
                                        .map(function(part) {
                                            return encodeURIComponent(part);
                                        })
                                        .join(&quot;+&quot;);
                }
                else
                    val = encodeURIComponent(msg[paramName]);
            }
            else
                val = msg[paramName];

            if (isUrlParam) {
                url = url.replace(&quot;:&quot; + paramName, val);
            }
            else {
                if (format == &quot;json&quot;)
                    ret.query[paramName] = val;
                else if (format != &quot;raw&quot;)
                    ret.query.push(paramName + &quot;=&quot; + val);
            }
        });
        ret.url = url;
        return ret;
    }

    /**
     *  Client#httpSend(msg, block, callback) -&gt; null
     *      - msg (Object): parameters to send as the request body
     *      - block (Object): parameter definition from the &#x60;routes.json&#x60; file that
     *          contains validation rules
     *      - callback (Function): function to be called when the request returns.
     *          If the the request returns with an error, the error is passed to
     *          the callback as its first argument (NodeJS-style).
     *
     *  Send an HTTP request to the server and pass the result to a callback.
     **/
    this.httpSend = function(msg, block, callback) {
        var self = this;
        var method = block.method.toLowerCase();
        var hasFileBody = block.hasFileBody;
        var hasBody = !hasFileBody &amp;&amp; (&quot;head|get|delete&quot;.indexOf(method) === -1);
        var format = getRequestFormat.call(this, hasBody, block);
        var obj = getQueryAndUrl(msg, block, format, self.config);
        var query = obj.query;
        var url = this.config.url ? this.config.url + obj.url : obj.url;

        var path = url;
        var protocol = this.config.protocol || this.constants.protocol || &quot;http&quot;;
        var host = block.host || this.config.host || this.constants.host;
        var port = this.config.port || this.constants.port || (protocol == &quot;https&quot; ? 443 : 80);
        var proxyUrl;
        if (this.config.proxy !== undefined) {
            proxyUrl = this.config.proxy;
        } else {
            proxyUrl = process.env.HTTPS_PROXY || process.env.HTTP_PROXY;
        }
        if (proxyUrl) {
            path = Url.format({
                protocol: protocol,
                hostname: host,
                port: port,
                pathname: path
            });

            if (!/^(http|https):\/\//.test(proxyUrl))
                proxyUrl = &quot;https://&quot; + proxyUrl;

            var parsedUrl = Url.parse(proxyUrl);
            protocol = parsedUrl.protocol.replace(&quot;:&quot;, &quot;&quot;);
            host = parsedUrl.hostname;
            port = parsedUrl.port || (protocol == &quot;https&quot; ? 443 : 80);
        }
        if (!hasBody &amp;&amp; query.length)
            path += &quot;?&quot; + query.join(&quot;&amp;&quot;);

        var headers = {
            &quot;host&quot;: host,
            &quot;content-length&quot;: &quot;0&quot;
        };
        if (hasBody) {
            if (format == &quot;json&quot;)
                query = JSON.stringify(query);
            else if (format != &quot;raw&quot;)
                query = query.join(&quot;&amp;&quot;);
            headers[&quot;content-length&quot;] = Buffer.byteLength(query, &quot;utf8&quot;);
            headers[&quot;content-type&quot;] = format == &quot;json&quot;
                ? &quot;application/json; charset=utf-8&quot;
                : format == &quot;raw&quot;
                    ? &quot;text/plain; charset=utf-8&quot;
                    : &quot;application/x-www-form-urlencoded; charset=utf-8&quot;;
        }
        if (this.auth) {
            var basic;
            switch (this.auth.type) {
                case &quot;oauth&quot;:
                    if (this.auth.token) {
                        path += (path.indexOf(&quot;?&quot;) === -1 ? &quot;?&quot; : &quot;&amp;&quot;) +
                            &quot;access_token=&quot; + encodeURIComponent(this.auth.token);
                    } else {
                        path += (path.indexOf(&quot;?&quot;) === -1 ? &quot;?&quot; : &quot;&amp;&quot;) +
                            &quot;client_id=&quot; + encodeURIComponent(this.auth.key) +
                            &quot;&amp;client_secret=&quot; + encodeURIComponent(this.auth.secret);
                    }
                    break;
                case &quot;token&quot;:
                    headers.authorization = &quot;token &quot; + this.auth.token;
                    break;
                case &quot;basic&quot;:
                    basic = new Buffer(this.auth.username + &quot;:&quot; + this.auth.password, &quot;ascii&quot;).toString(&quot;base64&quot;);
                    headers.authorization = &quot;Basic &quot; + basic;
                    break;
                default:
                    break;
            }
        }

        function callCallback(err, result) {
            if (callback) {
                var cb = callback;
                callback = undefined;
                cb(err, result);
            }
        }

        function addCustomHeaders(customHeaders) {
            Object.keys(customHeaders).forEach(function(header) {
                var headerLC = header.toLowerCase();
                if (self.requestHeaders.indexOf(headerLC) == -1)
                    return;
                headers[headerLC] = customHeaders[header];
            });
        }
        addCustomHeaders(Util.extend(msg.headers || {}, this.config.headers));

        if (!headers[&quot;user-agent&quot;])
            headers[&quot;user-agent&quot;] = &quot;NodeJS HTTP Client&quot;;

        if (!(&quot;accept&quot; in headers))
            headers.accept = this.config.requestMedia || this.constants.requestMedia;

        var options = {
            host: host,
            port: port,
            path: path,
            method: method,
            headers: headers
        };

        if (this.config.rejectUnauthorized !== undefined)
            options.rejectUnauthorized = this.config.rejectUnauthorized;

        if (this.debug)
            console.log(&quot;REQUEST: &quot;, options);

        function httpSendRequest() {
            var req = require(protocol).request(options, function(res) {
                if (self.debug) {
                    console.log(&quot;STATUS: &quot; + res.statusCode);
                    console.log(&quot;HEADERS: &quot; + JSON.stringify(res.headers));
                }
                res.setEncoding(&quot;utf8&quot;);
                var data = &quot;&quot;;
                res.on(&quot;data&quot;, function(chunk) {
                    data += chunk;
                });
                res.on(&quot;error&quot;, function(err) {
                    callCallback(err);
                });
                res.on(&quot;end&quot;, function() {
                    if (res.statusCode &gt;= 400 &amp;&amp; res.statusCode &lt; 600 || res.statusCode &lt; 10) {
                        callCallback(new error.HttpError(data, res.statusCode));
                    } else {
                        res.data = data;
                        callCallback(null, res);
                    }
                });
            });

            var timeout = (block.timeout !== undefined) ? block.timeout : self.config.timeout;
            if (timeout) {
                req.setTimeout(timeout);
            }

            req.on(&quot;error&quot;, function(e) {
                if (self.debug)
                    console.log(&quot;problem with request: &quot; + e.message);
                callCallback(e.message);
            });

            req.on(&quot;timeout&quot;, function() {
                if (self.debug)
                    console.log(&quot;problem with request: timed out&quot;);
                callCallback(new error.GatewayTimeout());
            });

            // write data to request body
            if (hasBody &amp;&amp; query.length) {
                if (self.debug)
                    console.log(&quot;REQUEST BODY: &quot; + query + &quot;\n&quot;);
                req.write(query + &quot;\n&quot;);
            }

            if (block.hasFileBody) {
              var stream = fs.createReadStream(msg.filePath);
              stream.pipe(req);
            } else {
              req.end();
            }
        };

        if (hasFileBody) {
            fs.stat(msg.filePath, function(err, stat) {
                if (err) {
                    callCallback(err);
                } else {
                    headers[&quot;content-length&quot;] = stat.size;
                    headers[&quot;content-type&quot;] = mime.lookup(msg.name);
                    httpSendRequest();
                }
            });
        } else {
            httpSendRequest();
        }
    };
}).call(Client.prototype);

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
